<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Minecraft-like 3D — Envanter + TNT + Lav + Obsidiyen + Portal</title>


<style>
html,body { height:100%; margin:0; background:#111; overflow:hidden; font-family:Segoe UI, Roboto, Arial }
#info { position:fixed; left:12px; top:12px; z-index:50; color:#ddd; background:rgba(0,0,0,0.45); padding:10px; border-radius:8px; }
#toolbar { position:fixed; left:12px; bottom:12px; z-index:50; display:flex; gap:8px; }
.slot { width:44px; height:44px; border-radius:6px; border:2px solid rgba(255,255,255,0.06); background-size:cover; background-position:center; box-shadow:0 6px 20px rgba(0,0,0,0.6); cursor:pointer }
.slot.selected { outline:3px solid rgba(255,255,255,0.85) }
#crosshair { position:fixed; left:50%; top:50%; width:18px; height:18px; margin-left:-9px; margin-top:-9px; z-index:49; pointer-events:none }
#crosshair:after { content:''; display:block; width:4px; height:4px; border-radius:50%; margin:7px auto; background:#fff }
#blockHint { position:fixed; right:12px; top:12px; z-index:50; background:rgba(0,0,0,0.45); color:#eee; padding:8px; border-radius:8px }
#overlay-underwater { position:fixed; inset:0; z-index:40; pointer-events:none; background:rgba(0,30,70,0.0) }
#inventory {
  position:fixed; inset:0; display:none; place-items:center; z-index:60;
  background:rgba(0,0,0,0.55); backdrop-filter: blur(2px);
}
#invPanel{
  background:rgba(12,12,12,0.9); border:1px solid rgba(255,255,255,0.08);
  padding:14px; border-radius:10px; color:#eee; width:min(720px,92vw);
  box-shadow:0 12px 40px rgba(0,0,0,0.6)
}
#invGrid{ display:grid; grid-template-columns:repeat(auto-fill, minmax(64px,1fr)); gap:10px; margin-top:10px }
.invSlot{
  height:64px; border-radius:8px; border:2px solid rgba(255,255,255,0.08);
  background-size:cover; background-position:center; cursor:pointer;
}
.invSlot:hover{ border-color:#fff }
canvas { display:block }
.small { opacity:0.8; font-size:12px; color:#bbb }

</style>
</head>
<body>
<div id="info">
  <strong>3D Voxel (Three.js)</strong><br>
  Tıklayın, fareyi kilitleyin ve oynayın.<br>
  W/S: ileri/geri — A/D: sağ/sol — (Zıplama yok)<br>
  Sol fare: kır — Sağ fare: koy — <b>E</b>: Envanter
</div>
<div id="blockHint">Seçili blok: <span id="blockName">Dirt</span></div>
<div id="toolbar"></div>
<div id="crosshair"></div>
<div id="overlay-underwater"></div>

<!-- Envanter -->
<div id="inventory">
  <div id="invPanel">
    <div><b>Envanter</b> <span class="small">— Bir bloka tıkla (E ile kapat)</span></div>
    <div id="invGrid"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// Eskisi gibi büyük olmasın:
const BLOCK_SIZE=1.0, GRID_W=48, GRID_H=48, GRID_D=48;
const EYE_HEIGHT = 1.2; // 2 blok boy için uygun göz hizası
const MAX_STEP = 1;

const PLAYER_RADIUS = 0.36; // simetrik tolerans için bir tık küçük


// --- WATER FLOW (ayarlar + veri yapıları) ---
const WATER_TICK_MS       = 150;     // su akış tik süresi (ms)
const WATER_MAX_PER_TICK  = 20;      // her tikte en fazla yeni hücre
const WATER_MAX_RANGE     = 5;       // kaynaktan en fazla kaç adım (Manhattan)
const WATER_COOLDOWN_MS   = 2000;    // su kırılınca geri dolma bekleme süresi

let   waterTimer = 0;

// Aktif su hücreleri (bu tikte işlenecek)
const waterActive = new Set();       // key: "x|y|z"

// Her su hücresinin kaynağa olan adım mesafesi (0 = kaynak)
const waterDist   = new Map();       // key -> distance (integer)

// Kırılan hücrelerde geri dolmayı erteleme
const waterCooldown = new Map();     // key -> cooldownSON (performance.now())

// Her aktif akışkan hücrenin türü
const waterType = new Map(); // key -> BLOCK.WATER/BLOCK.KETCAP/BLOCK.HARDAL

const wkey = (x,y,z) => `${x}|${y}|${z}`;

// Hücre ızgarasında güvenli mi?
function inRange(x,y,z){
  return x>=0 && y>=0 && z>=0 && x<GRID_W && y<GRID_H && z<GRID_D;
}

// Su akışını başlat/yeniden etkinleştir (mesafeyi tut)
function activateWater(x,y,z,dist=0,t=BLOCK.WATER){
  if (!inRange(x,y,z)) return;
  const k = wkey(x,y,z);
  waterType.set(k, t);
  const old = waterDist.get(k);
  // Daha kısa mesafeyle geliyorsa güncelle
  if (old === undefined || dist < old){
    waterDist.set(k, dist);
  }
  waterActive.add(k);
}


const GRAVITY = -22;   // ↓ yerçekimi (u/s^2)
const JUMP_V  = 7.0;   // ↑ ~1 bloktan biraz fazla zıplama


// Dokular (AYNEN senin verdiklerin)
const TEX = {
  dirt:'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRvJmdfF1rbNy8hPiV7Y4Zk8LQq2DVII6vvbA&s',
  gravel:'https://p.novaskin.me/3227683066.png?class=thumbnail',
  stone:'https://p.novaskin.me/1rh3gqcxpyp.png?class=thumbnail',
  wood:'https://p.novaskin.me/3835313885.png?class=thumbnail',
  sand:'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRRIFznsJS37WaQCbXa4UJ8L51DLAnJQ1hvEA&s',
  plank:'https://p.novaskin.me/5736853225.png',
  water:'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRsFRp0JoDCeuAuE4Kpzv5Q08tkk34U-ofd1w&s',
  grass_side:'https://static.wikia.nocookie.net/minecraft_gamepedia/images/3/3b/Grass_Block_%28side_texture%29_JE2_BE2.png/revision/latest?cb=20200921204925',
  grass_top:'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQAKhPqte9xg9p6EFXEtmku52Llhhf7v7gLF5lCbiRvzAFzyYxNlKBcgAezD_4IrzUypGU&usqp=CAU',
  pig:'https://media.tenor.com/xmQHvbjDqIQAAAAj/minecraft.gif',
  villager:'https://r2.mcpedl.com/submissions/97539/images/new-villager-animations_2.gif',
  glass:'https://p.novaskin.me/6507933547.png?class=thumbnail',
  glowstone:'https://p.novaskin.me/eagmwq6drc.png?class=thumbnail',
  // Yeni bloklar
  tnt_top:'https://art.pixilart.com/fcb74b87e766d79.png',
  tnt_bottom:'https://art.pixilart.com/b5785ba1c988426.png',
  tnt_side:'https://p.novaskin.me/5096833490.png?class=thumbnail',
  lava:'https://mcdf.wiki.gg/images/d/dd/Lava_Texture_Item.jpg?269d27',
  obsidian:'https://p.novaskin.me/26p0u0bn7s8.png?class=thumbnail',

  // --- Yeni dokular ---
  ketcap:'https://blogger.googleusercontent.com/img/a/AVvXsEjKpxsvdb1WGvt1BjkjieNEjt5_ppY6JR2t55hRdvp5-Nd3jtDJlcSe5LhMzSS13HbAs6wJMxqP5qHt5VfNNnek_RVGCwAB4OYf6MQw2nAKA0Gbbv95WKN7Ax91H_awHYfgt94kfujdmQJIGXhDPDOBkXMA7VqasHurLJankdTSKtA7HOvZm0_596roJ460=s16000',   // ketçap
  hardal:'https://blogger.googleusercontent.com/img/a/AVvXsEhquk2uE_C1TNApbbi_tMDqIPhFjlEWIpfgmZPIKDgo1X8QWASzcTIbu8HrzPuclZSV1XS5fBLbFV3VchMlCoc8vSMxGOVBU9BM9Gl9L7xt-jx4v_Vtt-mAmh49C2PcJyquMTjVyDSu28iGOmMmwdSuNxcrVY10qp3QVqbLPlsLr-EAFsA7glci7Mk40aN9=s16000',    // hardal
  spagetti:'https://blogger.googleusercontent.com/img/a/AVvXsEg3gspUBTFVJhqZX8-dFB0FNusjFi8HVKuBhNZfwlXxY0zGssN0tX2ywK4RuVYrCo9aVOsfkFWN_epG-J6FkpkvssxI4-yzhssO51Js7UE4rGtaxcECVWxI150FYHsyHbwQOZNi33avGKgUsdtH0CogUInGU3L1BcyXvF_Kx2w-8-DbwLB-iVDDryLdTvoO=s16000', // spagetti
  kurdele:'https://blogger.googleusercontent.com/img/a/AVvXsEi42xzFjCt66sJ77zdcVufPqVjG_Rf-H3bsbx_cCi8NO-lVqhQ_WY1jWI1g-vIjdjkp8wfEX6DcZLFpHDGCa5PE_AsMw753ShwvO3IPlLJvhBwCl1-2d1g9yXVyik2pg2GYhrkV7Qj9WkfH0BzAw_BqnflYbfLZlyWYAWNZ8RtqFpNqoZs3a3OvLUh4JeVW=s16000', // kurdele
  burgu:'https://blogger.googleusercontent.com/img/a/AVvXsEhm4E3rhjNyklDlrE7xCmq6aN250Ct1MexYcgt7DtzBzqxIBfeLN7GSKG5FrCCiSznt_oOfbc4_2FZuC6RyXk3Im0VTxBt9o4-Ha9Z_OSpbROr7CHUoreCKQ4tcVkBqRL_9GoRfYIw2BXFCQCjw6OzRR2IX5vUvExIy7E68d_CqOAHFpbC10GO4p5VLPUMQ=s16000', // burgu
  konik:'https://blogger.googleusercontent.com/img/a/AVvXsEhS2T0RmqwFgrKpuG6dDqjZHaRE5VdKSAPTp-75htKg8VwL4dxxLX1sznjZ6L7ZgwKrhTtsp8A7e8IP6mfl4TbEUJIVu2DkDCIvBT2F629gLaMQjIr-86e_nu94oVkkA6Ilxm7CWAgKwISejmYfkDwUaOSnLVDmoERc8bRurOaPY2BxmBsWm7y55Zu1XRRb=s16000', // konik
  patates:'https://blogger.googleusercontent.com/img/a/AVvXsEhmhgj77M5_1VS9TREG8hMb8NbRNW0jtj8pxoV0Yp5BTXYMwKC-5_c1VAiRXIrRoAEosnrPUZ5XHUqxr4Ii14FvDgRX-H4WfBa2k0UuT4KpbeESdmkRPGIYqk_A4Zd0FpgqgMlF3GndTVji7pcYN2W50WuxfGkibtAFnuGV805xhRua9von_VyUNi8hlWzl=s16000' // patates

};

const BLOCK = {
  AIR:0, DIRT:1, GRAVEL:2, STONE:3, WOOD:4, SAND:5, PLANK:6, WATER:7, GRASS:8,
  PIG:9, VILLAGER:10, GLASS:11, GLOWSTONE:12,
  TNT:13, LAVA:14, OBSIDIAN:15, PORTAL:16  , KETCAP:17, HARDAL:18, SPAGETTI:19, KURDELE:20, BURGU:21, KONIK:22, PATATES:23

};
const NAMES = {
  1:'Dirt',2:'Gravel',3:'Stone',4:'Wood',5:'Sand',6:'Plank',7:'Water',8:'Grass',
  11:'Glass',12:'Glowstone',13:'TNT',14:'Lava',15:'Obsidian',16:'Portal' ,17:'Ketçap',18:'Hardal',19:'Spagetti',20:'Kurdele',21:'Burgu',22:'Konik',23:'Patates'

};

// Akışkan blok seti (su benzeri): ketçap + hardal + su
const FLUIDS = new Set([BLOCK.WATER, BLOCK.KETCAP, BLOCK.HARDAL, BLOCK.LAVA]);


// Scene & camera
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x87ceeb);
const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.01,300);
camera.rotation.order = 'YXZ'; // yaw→pitch, roll kilitli kalsın
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight); renderer.setPixelRatio(Math.min(2,window.devicePixelRatio));
document.body.appendChild(renderer.domElement);
window.addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});

// Işıklar
scene.add(new THREE.HemisphereLight(0xffffff,0x444444,0.85));
const dir = new THREE.DirectionalLight(0xffffff,0.5); dir.position.set(5,10,7); scene.add(dir);

// Grid
let grid = Array.from({length:GRID_D},()=>Array.from({length:GRID_H},()=>Array(GRID_W).fill(BLOCK.AIR)));

// --------- DÜZ DÜNYA KURULUMU (hafif) ---------
function buildFlatWorld() {
  // her şeyi AIR yap
  for (let z=0; z<GRID_D; z++)
    for (let y=0; y<GRID_H; y++)
      for (let x=0; x<GRID_W; x++)
        grid[z][y][x] = BLOCK.AIR;

  // Zemin: z=0..1 DIRT, z=2 GRASS (taşma olmasın diye clamp)
  const z0 = 0;
  const z1 = Math.min(1, GRID_D-1);
  const z2 = Math.min(2, GRID_D-1);
  for (let y=0; y<GRID_H; y++) {
    for (let x=0; x<GRID_W; x++) {
      if (z0 >= 0) grid[z0][y][x] = BLOCK.DIRT;
      if (z1 >= 0) grid[z1][y][x] = BLOCK.DIRT;
      if (z2 >= 0) grid[z2][y][x] = BLOCK.GRASS;
    }
  }

// 1 adet göl (yüzey z=z2'de)
const lakeZ = z2;
if (lakeZ >= 0) {
  const lake = {
    x0: Math.floor(GRID_W*0.55),
    x1: Math.floor(GRID_W*0.85),
    y0: Math.floor(GRID_H*0.55),
    y1: Math.floor(GRID_H*0.85)
  };
  // Gölü PASİF doldur (AKTİFLEŞTİRME YOK)
  for (let y=lake.y0; y<lake.y1; y++) {
    for (let x=lake.x0; x<lake.x1; x++) {
      grid[lakeZ][y][x] = BLOCK.WATER;                 // su yüzeyi
      if (lakeZ-1 >= 0) grid[lakeZ-1][y][x] = BLOCK.DIRT; // taban
    }
  }
  // Sadece ORTADAKİ 1 hücreyi kaynak yap (20 hücreye kadar yayılır)
  const cx = Math.floor((lake.x0 + lake.x1)/2);
  const cy = Math.floor((lake.y0 + lake.y1)/2);
  activateWater(cx, cy, lakeZ, 0, BLOCK.WATER);
}


  // 3–5 ağaç
  const treeCount = 4;
  for (let i=0; i<treeCount; i++) {
    const tx = Math.floor(GRID_W*0.15) + Math.floor(Math.random()*Math.floor(GRID_W*0.3));
    const ty = Math.floor(GRID_H*0.15) + Math.floor(Math.random()*Math.floor(GRID_H*0.3));
    placeTree(tx, ty, 4 + Math.floor(Math.random()*2));
  }
}

// Basit ağaç (gövde: WOOD, yaprak: PLANK)
function placeTree(ix, iy, h=5) {
  // Gövdeyi zeminin biraz üstünden başlat (GRID_D küçükse uyum sağla)
  const baseZ = Math.min(3, Math.max(0, GRID_D-2));
  for (let z=baseZ; z<baseZ+h && z<GRID_D; z++) {
    if (safeIn(ix, iy, z)) grid[z][iy][ix] = BLOCK.WOOD;
  }

  // Yaprak kümesi
  const topZ = Math.min(baseZ + h - 1, GRID_D - 1);
  for (let z=Math.max(baseZ, topZ-1); z<=topZ; z++) {
    for (let dy=-2; dy<=2; dy++) for (let dx=-2; dx<=2; dx++) {
      const xx = ix+dx, yy = iy+dy;
      if ((Math.abs(dx)+Math.abs(dy)) <= 3) {
        if (safeIn(xx, yy, z) && grid[z][yy][xx] === BLOCK.AIR) {
          grid[z][yy][xx] = BLOCK.PLANK; // ← enum adını seninkine göre ayarla
        }
      }
    }
  }
  if (safeIn(ix, iy, topZ+1)) grid[topZ+1][iy][ix] = BLOCK.PLANK;
}

function safeIn(x,y,z){
  return x>=0 && y>=0 && z>=0 && x<GRID_W && y<GRID_H && z<GRID_D;
}


// Bu hücreye şimdi su dolabilir mi? (cooldown ve doluluk kontrolü)
function canFillWater(x,y,z, nowMs){
  if (!inRange(x,y,z)) return false;      // inRange: biz su sabitleri bölümünde tanımladık
  if (grid[z][y][x] !== BLOCK.AIR) return false;
  const k = wkey(x,y,z);
  const until = waterCooldown.get(k);
  if (until !== undefined && nowMs < until) return false; // cooldown devam
  return true;
}

// Su akışı: önce aşağı (z-1), sonra aynı seviyeye; menzil ve hız sınırlı
function stepWater(maxNew = WATER_MAX_PER_TICK){
  if (waterActive.size === 0) return;

  const now = performance.now();
  const batch = Array.from(waterActive);
  let placed = 0;

  for (let i = 0; i < batch.length && placed < maxNew; i++){
    const k = batch[i];
    const [sx,sy,sz] = k.split('|').map(Number);

    // cooldown kontrolü
    const ck = wkey(sx,sy,sz);
    const cd = waterCooldown.get(ck) ?? 0;
    if (cd > now) continue;

    const curDist = waterDist.get(k) ?? 0;
    const tFluid  = waterType.get(k) ?? BLOCK.WATER; // WATER / LAVA / KETCAP / HARDAL

    // Tür bazlı mesafe limiti (yoksa 20)
    const LIMIT = (typeof FLUID_MAX_DIST_BY_TYPE !== 'undefined' && FLUID_MAX_DIST_BY_TYPE[tFluid] !== undefined)
      ? FLUID_MAX_DIST_BY_TYPE[tFluid]
      : 20;

    // Bu hücre zaten limite ulaştıysa yayma
    if (curDist >= LIMIT) continue;

    // ↓ AŞAĞI AKIŞ
    const dz = sz - 1;
    if (curDist + 1 <= LIMIT && dz >= 0 && dz < GRID_D && grid[dz][sy][sx] === BLOCK.AIR){
      setBlock(sx,sy,dz, tFluid, {suppressFluid:true});           // ← motor kaynak oluşturmasın
      activateWater(sx,sy,dz, curDist + 1, tFluid);
      activateWater(sx,sy,sz, curDist, tFluid); // kaynağı aktif tut
      placed++;
      continue;
    }

    // → YANA AKIŞ (4 yön)
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for (const [dx,dy] of dirs){
      if (placed >= maxNew) break;
      const nx = sx + dx, ny = sy + dy, nz = sz;
      if (!inRange(nx,ny,nz)) continue;

      if (curDist + 1 > LIMIT) continue; // sınırı aşma
      if (grid[nz][ny][nx] === BLOCK.AIR){
        setBlock(nx,ny,nz, tFluid, {suppressFluid:true});         // ← motor kaynak oluşturmasın
        activateWater(nx,ny,nz, curDist + 1, tFluid);
        placed++;
      }
    }
  }
}


// --- grid dizileri (grid = [...]) oluşturulduktan hemen sonra: ---
buildFlatWorld();

// Materials
const loader = new THREE.TextureLoader();
loader.setCrossOrigin('anonymous');

function basicMat(url, opt = { transparent:false, opacity:1, emissive:0x000000 }) {
  const t = loader.load(
    url,
    undefined,
    undefined,
    () => {
      console.warn('Doku yüklenemedi (CORS?):', url);
    }
  );
  t.magFilter = THREE.NearestFilter;
  t.minFilter = THREE.LinearMipMapLinearFilter;
  return new THREE.MeshStandardMaterial({
    map: t,
    transparent: opt.transparent,
    opacity: opt.opacity,
    emissive: new THREE.Color(opt.emissive)
  });
}

// CORS başlığı vermeyen kaynakları proxy'le
function corsify(rawUrl){
  try {
    const u = new URL(rawUrl);
    // proxy'lemek istediğimiz hostları buraya ekleyebiliriz
    const needsProxy = [
      'blogger.googleusercontent.com',
      'encrypted-tbn0.gstatic.com',
      'p.novaskin.me',
      'mcdf.wiki.gg',
      'media.tenor.com',
      'r2.mcpedl.com',
      'art.pixilart.com'
    ].includes(u.host);
    if (!needsProxy) return rawUrl;

    // images.weserv.nl şemayı istemez; ssl: ile https zorlarız
    const withoutScheme = rawUrl.replace(/^https?:\/\//, '');
    return 'https://images.weserv.nl/?url=ssl:' + withoutScheme + '&output=png';
  } catch (e){
    // Geçersiz URL geldiyse olduğu gibi döndür
    return rawUrl;
  }
}

function basicMat(url, opt = { transparent:false, opacity:1, emissive:0x000000 }) {
  const proxied = corsify(url);
  const t = loader.load(
    proxied,
    undefined,
    undefined,
    () => console.warn('Doku yüklenemedi (CORS?):', proxied)
  );
  t.magFilter = THREE.NearestFilter;
  t.minFilter = THREE.LinearMipMapLinearFilter;
  return new THREE.MeshStandardMaterial({
    map: t,
    transparent: opt.transparent,
    opacity: opt.opacity,
    emissive: new THREE.Color(opt.emissive)
  });
}


function colorMat(color, {opacity=1, transparent=false, emissive=0x000000}={}){
  return new THREE.MeshStandardMaterial({
    color, opacity, transparent,
    emissive: new THREE.Color(emissive)
  });
}

const mats={};
mats[BLOCK.DIRT]=basicMat(TEX.dirt);
mats[BLOCK.GRAVEL]=basicMat(TEX.gravel);
mats[BLOCK.STONE]=basicMat(TEX.stone);
mats[BLOCK.WOOD]=basicMat(TEX.wood);
mats[BLOCK.SAND]=basicMat(TEX.sand);
mats[BLOCK.PLANK]=basicMat(TEX.plank);
mats[BLOCK.WATER]=basicMat(TEX.water);
mats[BLOCK.GLASS]=basicMat(TEX.glass);
mats[BLOCK.GLOWSTONE]=basicMat(TEX.glowstone,{emissive:0x775533});
mats[BLOCK.LAVA] = basicMat(TEX.lava, { emissive: 0x552200 });
mats[BLOCK.OBSIDIAN]=basicMat(TEX.obsidian,{emissive:0x111122});
mats[BLOCK.KETCAP]   = basicMat(TEX.ketcap);
mats[BLOCK.HARDAL]   = basicMat(TEX.hardal);
mats[BLOCK.SPAGETTI] = basicMat(TEX.spagetti);
mats[BLOCK.KURDELE]  = basicMat(TEX.kurdele);
mats[BLOCK.BURGU]    = basicMat(TEX.burgu);
mats[BLOCK.KONIK]    = basicMat(TEX.konik);
mats[BLOCK.PATATES]  = basicMat(TEX.patates);



// TNT: 6 yüz (right,left,top,bottom,front,back)
function tntMaterialsArray(){
  const side = basicMat(TEX.tnt_side);
  const top  = basicMat(TEX.tnt_top);
  const bot  = basicMat(TEX.tnt_bottom);
  return [side,side,top,bot,side,side];
}

// Grass materyal dizisi
function grassMaterialsArray(){
  const matGrassSide=basicMat(TEX.grass_side);
  const matGrassTop=basicMat(TEX.grass_top);
  const matDirt=mats[BLOCK.DIRT];
  return [matGrassSide,matGrassSide,matGrassTop,matDirt,matGrassSide,matGrassSide];
}

// Portal materyali
const portalMat = new THREE.MeshBasicMaterial({color:0x8833ff, opacity:0.55, transparent:true, side:THREE.DoubleSide});

// Geometry & gruplar
const cubeGeo = new THREE.BoxGeometry(BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
const blocksGroup = new THREE.Group(); scene.add(blocksGroup);
function posFor(x,y,z){ return new THREE.Vector3((x+0.5-GRID_W/2)*BLOCK_SIZE,(z+0.5)*BLOCK_SIZE,(y+0.5-GRID_H/2)*BLOCK_SIZE); }

// Yardımcı
function keyOf(x,y,z){ return `${x},${y},${z}`; }

// Glowstone ışıkları
const glowLights = new Map();
function addGlowLight(x,y,z){
  const light = new THREE.PointLight(0xffddaa,1.15,6);
  light.position.copy(posFor(x,y,z));
  scene.add(light);
  glowLights.set(keyOf(x,y,z),light);
}

function removeGlowLight(x,y,z){
  const k=keyOf(x,y,z);
  const l=glowLights.get(k);
  if(l){ scene.remove(l); glowLights.delete(k); }
}

// Mesh map
const meshesMap=new Map();

function createMeshForBlock(x, y, z, t){
  // Akışkanlar: su / ketçap / hardal / lava
  if (FLUIDS.has(t)) {
    const m = mats[t].clone();

    if (t === BLOCK.WATER) {
      // Su: yarı saydam
      m.opacity = 0.60;
      m.transparent = true;
    } else if (t === BLOCK.KETCAP) {
      // Ketçap: hafif şeffaf
      m.opacity = 0.85;
      m.transparent = true;
    } else if (t === BLOCK.HARDAL) {
      // Hardal: ketçaptan bir tık daha şeffaf
      m.opacity = 0.80;
      m.transparent = true;
    } else {
      // Lava: opak (doku tam görünsün)
      m.opacity = 1.0;
      m.transparent = false;
    }

    const mesh = new THREE.Mesh(cubeGeo, m);
    mesh.position.copy(posFor(x, y, z));
    mesh.userData = { x, y, z, t };
    return mesh;
  }

  // Diğer bloklar
  let matOrArray;
  if (t === BLOCK.GRASS) {
    matOrArray = grassMaterialsArray();
  } else if (t === BLOCK.TNT) {
    matOrArray = tntMaterialsArray();
  } else if (t === BLOCK.PORTAL) {
    matOrArray = portalMat;
  } else {
    matOrArray = mats[t] || mats[BLOCK.DIRT];
  }

  const mesh = new THREE.Mesh(cubeGeo, matOrArray);
  mesh.position.copy(posFor(x, y, z));
  mesh.userData = { x, y, z, t };
  return mesh;
}

function addBlockMesh(x,y,z,t){
  const mesh=createMeshForBlock(x,y,z,t);
  blocksGroup.add(mesh); meshesMap.set(keyOf(x,y,z),mesh);
  if(t===BLOCK.GLOWSTONE) addGlowLight(x,y,z);
}
function removeBlockMesh(x,y,z){
  const k=keyOf(x,y,z); const m=meshesMap.get(k);
  if(m){
    if(m.userData.t===BLOCK.GLOWSTONE) removeGlowLight(x,y,z);
    blocksGroup.remove(m); m.geometry.dispose?.(); meshesMap.delete(k);
  }
}

function setBlock(x,y,z,t, opts = {}){
  if(z<0||z>=GRID_D||y<0||y>=GRID_H||x<0||x>=GRID_W) return;
  const prev = grid[z][y][x];
  if(prev === t) return;

  const suppressFluid = !!opts.suppressFluid; // ← motorun yerleştirdiklerinde true gönder


  // Mevcut mesh'i temizle
  if(prev !== BLOCK.AIR) removeBlockMesh(x,y,z);

  // Grid'i güncelle
  grid[z][y][x] = t;

  // Yeni mesh'i ekle
  if(t !== BLOCK.AIR) addBlockMesh(x,y,z,t);


// --- AKIŞKAN AKIŞ TETİKLEYİCİSİ ---
if (FLUIDS.has(t) && !suppressFluid){
  // Oyuncu koydu → bu hücre KAYNAK (mesafe 0)
  activateWater(x,y,z, 0, t);
} else if (t === BLOCK.AIR){
  // Oyuncu kırdı → SADECE 1 komşu sıvıyı KAYNAK yap (öncelik: yukarı → yanlar → aşağı)
  const nn = [
    [0,0,1],   // üst
    [1,0,0],[-1,0,0],[0,1,0],[0,-1,0], // yanlar
    [0,0,-1]   // alt
  ];
  for (const [dx,dy,dz] of nn){
    const nx=x+dx, ny=y+dy, nz=z+dz;
    if (!inRange(nx,ny,nz)) continue;
    const nb = grid[nz][ny][nx];
    if (FLUIDS.has(nb)){
      activateWater(nx,ny,nz, 0, nb); // sadece İLK bulduğunu kaynak yap
      break;
    }
  }
}



// Önceki blok akışkansa ve şimdi AIR ise → cooldown
if (FLUIDS.has(prev) && t === BLOCK.AIR){
  waterCooldown.set(wkey(x,y,z), performance.now() + WATER_COOLDOWN_MS);
}



  // -------------------------------------------

  // Obsidiyen konduğunda portal dene
  if (t === BLOCK.OBSIDIAN) tryFormPortalAt(x,y,z);
}


function rebuildMeshes(){
  // temizle
  while(blocksGroup.children.length) blocksGroup.remove(blocksGroup.children[0]);
  meshesMap.clear();
  glowLights.forEach(l=>scene.remove(l)); glowLights.clear();
  // tekrar ekle
  for(let z=0; z<GRID_D; z++) for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++){
    const t=grid[z][y][x]; if(t===BLOCK.AIR) continue; addBlockMesh(x,y,z,t);
  }
}

// Ağaç üretimi (wood+glass+glowstone)
function topSolidZ(ix,iy){
  if(ix<0||iy<0||ix>=GRID_W||iy>=GRID_H) return -1;
  for(let z=GRID_D-1; z>=0; z--) if(grid[z][iy][ix]!==BLOCK.AIR && grid[z][iy][ix]!==BLOCK.WATER && grid[z][iy][ix]!==BLOCK.LAVA && grid[z][iy][ix]!==BLOCK.PORTAL) return z;
  return -1;
}

// Bir (ix, iy) sütununda YÜRÜNEBİLİR tepe yüksekliği (blok üst yüzeyi)
// Not: Sıvılar ve PORTAL üstü "zemin" sayılmaz; katı blok üstü sayılır.
// DÖNEN DEĞER: hücre Z indeksi (tam sayı) — oyuncu.z = returned + EYE_HEIGHT

function walkableTopZ(ix, iy){
  if (ix < 0 || iy < 0 || ix >= GRID_W || iy >= GRID_H) return 0;

  // En üstten aşağı tara: ilk katı bloğun TEPE yüzeyi = z+1
  for (let z = GRID_D - 1; z >= 0; z--){
    const b = grid[z]?.[iy]?.[ix] ?? BLOCK.AIR;
    if (b !== BLOCK.AIR && b !== BLOCK.PORTAL && !FLUIDS.has(b)){
      return z + 1;
    }
  }
  // Kolon tamamen boşsa zemin 0 kabul
  return 0;
}


// Sürekli konum → hücre endeksi (merkezlere göre, simetrik)
const cellIdx = v => Math.floor(v + 0.5);


function isSolidAt(ix, iy, iz){
  if (iz < 0 || iz >= GRID_D || iy < 0 || iy >= GRID_H || ix < 0 || ix >= GRID_W) return false;
  const b = grid[iz][iy][ix];
  // Üzerinde yürünemeyen, “katı” bloklar
  return !(b === BLOCK.AIR || FLUIDS.has(b) || b === BLOCK.LAVA || b === BLOCK.PORTAL);
}


// Daire (merkez cx,cy; yarıçap r) ile [ix,ix+1]x[iy,iy+1] karesi
// SADECE gerçek penetrasyonda true döner (dokunma ≠ çarpışma)
function cellOverlapsCircle(cx, cy, ix, iy, r){
  const closestX = Math.max(ix, Math.min(cx, ix + 1));
  const closestY = Math.max(iy, Math.min(cy, iy + 1));
  const dx = cx - closestX, dy = cy - closestY;
  // Eşik: sadece d^2 < r^2 ise çarpışma; eşitlik (dokunma) çarpışma sayılmaz
  return (dx*dx + dy*dy) < (r*r - 1e-4);
}


function canStandAt(x, y, baseZ){
  const r = PLAYER_RADIUS;
  const EPS = 1e-4; // sınırda asimetriyi kırmak için küçük pay

  // Tarama aralığını simetrik + küçük payla al
  const ix0 = Math.floor(x - r - EPS), ix1 = Math.floor(x + r + EPS);
  const iy0 = Math.floor(y - r - EPS), iy1 = Math.floor(y + r + EPS);

  for (let iy = iy0; iy <= iy1; iy++){
    for (let ix = ix0; ix <= ix1; ix++){
      if (!cellOverlapsCircle(x, y, ix, iy, r)) continue; // daire kareye girmiyor → geç
      // 2 blok boy: baseZ+1 ve baseZ+2 boş olmalı
      if (isSolidAt(ix, iy, baseZ + 1) || isSolidAt(ix, iy, baseZ + 2)) return false;
    }
  }
  return true;
}


// Hedef hücrede (ix,iy) taban baseZ iken, oyuncunun kapladığı
// iki kat (baseZ+1 ve baseZ+2) içinde SU var mı?
function isFluidColumn(ix, iy, baseZ){
  if (ix<0 || iy<0 || ix>=GRID_W || iy>=GRID_H) return false;
  const z1 = baseZ + 1, z2 = baseZ + 2;
  const b1 = (z1>=0 && z1<GRID_D) ? grid[z1][iy][ix] : BLOCK.AIR;
  const b2 = (z2>=0 && z2<GRID_D) ? grid[z2][iy][ix] : BLOCK.AIR;
  return FLUIDS.has(b1) || FLUIDS.has(b2);
}


// SKIN yoksa küçük bir pay tanımla
const SKIN = 0.01;

// Eksen bazlı çarpışma çözümü: 4 yönde de sıfıra-sıfır
// Duvarlardan dışarı itme — simetrik ve kararlı

function resolveWallCollisions(){
  const r    = PLAYER_RADIUS;
  const SKIN = 0.0005;  // daha da küçük pay → kenarda itme azalır
  const EPS  = 1e-6;

  const baseZ = Math.max(0, Math.floor(player.z - EYE_HEIGHT));

  for (let pass = 0; pass < 2; pass++){
    let moved = false;

    const px = player.x, py = player.y;

    // Merkez-simetrik tarama
    const ix0 = cellIdx(px - r - 0.5) - 1;
    const ix1 = cellIdx(px + r + 0.5) + 1;
    const iy0 = cellIdx(py - r - 0.5) - 1;
    const iy1 = cellIdx(py + r + 0.5) + 1;

    for (let iy = iy0; iy <= iy1; iy++){
      for (let ix = ix0; ix <= ix1; ix++){
        if (!(isSolidAt(ix,iy,baseZ+1) || isSolidAt(ix,iy,baseZ+2))) continue;

        const cx = ix + 0.5, cy = iy + 0.5;
        const dx = px - cx,   dy = py - cy;

        let overX = (r + 0.5) - Math.abs(dx);
        let overY = (r + 0.5) - Math.abs(dy);

        // Sadece gerçek penetrasyonda it; "dokunma"yı itme sayma
        if (overX <= SKIN || overY <= SKIN) continue;

        overX -= SKIN; overY -= SKIN;

        if (Math.abs(overX - overY) > EPS){
          if (overX < overY){
            player.x += (dx < 0 ? -overX : overX);
          } else {
            player.y += (dy < 0 ? -overY : overY);
          }
        } else {
          // Tam eşitlikte tarafsız seçim
          if (Math.abs(dx) >= Math.abs(dy)){
            player.x += (dx < 0 ? -overX : overX);
          } else {
            player.y += (dy < 0 ? -overY : overY);
          }
        }
        moved = true;
      }
    }
    if (!moved) break;
  }
}



// Dünya tipleri
let world = "overworld"; // veya "nether"

// Nether dünyasını basitçe oluştur
function buildNether(){
  for(let z=0; z<GRID_D; z++) for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++){
    grid[z][y][x] = (z===0) ? BLOCK.OBSIDIAN :
                    (z<3) ? BLOCK.NETHERRACK||BLOCK.STONE : 
                    (Math.random()<0.1?BLOCK.LAVA:BLOCK.AIR);
  }
  rebuildMeshes();
}

// Portala girme kontrolü
function checkPortal(){
  const ix=Math.floor((camera.position.x/BLOCK_SIZE)+GRID_W/2);
  const iy=Math.floor((camera.position.z/BLOCK_SIZE)+GRID_H/2);
  const iz=Math.floor((camera.position.y/BLOCK_SIZE));
  const b=(grid[iz]?.[iy]?.[ix])|0;
  if(b===BLOCK.PORTAL){
    if(world==="overworld"){
      world="nether"; buildNether();
      player.x=GRID_W/2; player.y=GRID_H/2; player.z=5+EYE_HEIGHT;
    } else {
      world="overworld"; // Tekrar normal dünyayı kur
      location.reload(); // basit çözüm: sayfayı yenile
    }
  }
}
function tryPlace(x,y,z,t){ if(z>=0&&z<GRID_D&&y>=0&&y<GRID_H&&x>=0&&x<GRID_W && grid[z][y][x]===BLOCK.AIR){ grid[z][y][x]=t; } }
(function scatterTrees(){
  const count = 24;
  let placed=0, tries=0;
  while(placed<count && tries<800){
    tries++;
    const x = Math.floor(Math.random()*GRID_W);
    const y = Math.floor(Math.random()*GRID_H);
    const ground = topSolidZ(x,y);
    if(ground<0) continue;
    const groundBlock = grid[ground][y][x];
    if(!(groundBlock===BLOCK.GRASS || groundBlock===BLOCK.DIRT || groundBlock===BLOCK.SAND)) continue;
    const h = 3 + Math.floor(Math.random()*3);
    let ok=true;
    for(let i=1;i<=h;i++){ if(isSolidAt(x,y,ground+i)) { ok=false; break; } }
    if(!ok) continue;
    for(let i=1;i<=h;i++){ grid[ground+i][y][x]=BLOCK.WOOD; }
    const topZ = ground+h;
    const r = 2;
    for(let dz=-r; dz<=r; dz++)
      for(let dy=-r; dy<=r; dy++)
        for(let dx=-r; dx<=r; dx++){
          const dist = Math.abs(dx)+Math.abs(dy)+Math.abs(dz);
          const tx=x+dx, ty=y+dy, tz=topZ+dz;
          if(dist<=r+1){
            if(dx===0 && dy===0 && dz===0){
              tryPlace(tx,ty,tz,BLOCK.GLOWSTONE);
            } else if(dist>=1){
              tryPlace(tx,ty,tz,BLOCK.GLASS);
            }
          }
        }
    placed++;
  }
})();

rebuildMeshes();

// Player
const player = {
  x: GRID_W/2,
  y: GRID_H/2,
  z: 5,
  yaw: 0,
  pitch: 0,
  vz: 0,              // dikey hız (zıplama/yerçekimi için)
  grounded: false,    // yere temas durumu
  speed: 0.0          // (kullanılmıyorsa kaldırılabilir)
};

(function snapToGroundAtStart(){
  const ix = cellIdx(player.x), iy = cellIdx(player.y);
  const zTop = walkableTopZ(ix, iy);
  player.z = (zTop < 0 ? 0 : zTop) + EYE_HEIGHT;
})();

// Pointer lock + mouse (sağlam sürüm)
renderer.domElement.setAttribute('tabindex','0'); // odaklanabilir olsun

function enablePointerLock() {
  const el = renderer.domElement;
  // Sayfa odağını garanti et
  if (document.activeElement !== el) el.focus();
  if (document.pointerLockElement !== el) {
    el.requestPointerLock();
  }
}

// click yerine mousedown daha tutarlı
renderer.domElement.addEventListener('mousedown', enablePointerLock);

// Pointer lock değişimlerini takip et
function onPointerLockChange(){
  const el = renderer.domElement;
  const locked = (document.pointerLockElement === el);
  if (locked){
    document.addEventListener('mousemove', onMouseMove);
  } else {
    document.removeEventListener('mousemove', onMouseMove);
  }
}
document.addEventListener('pointerlockchange', onPointerLockChange);
document.addEventListener('pointerlockerror', ()=> {
  console.warn('Pointer lock alınamadı (tarayıcı engeli veya element çakışması).');
});

// Fare hareketi → kamera
function onMouseMove(e){
  player.yaw   -= e.movementX * 0.0025;
  player.pitch -= e.movementY * 0.0025;
  player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.pitch));
  camera.rotation.set(player.pitch, player.yaw, 0);
}


// Keys
const keys = {};
window.addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  keys[k] = true;

  // Space (zıplama) — hem e.code hem e.key kontrolü
  if (e.code === 'Space' || e.key === ' ') {
    keys['space'] = true;          // animate() içinde bunu okuyacağız
    // keys[' '] = true;           // istersen bunu da set edebilirsin
    e.preventDefault();            // sayfanın aşağı kaymasını engelle
  }

  // Envanter toggle
  if (k === 'e'){
    toggleInventory();
    e.preventDefault();
  }
});

window.addEventListener('keyup', (e)=>{
  const k = e.key.toLowerCase();
  keys[k] = false;

  // Space bırakma
  if (e.code === 'Space' || e.key === ' ') {
    keys['space'] = false;
    // keys[' '] = false;
    e.preventDefault();
  }
});

// Raycast
const raycaster = new THREE.Raycaster();
raycaster.far = 6;
function getCenterRay(){
  const dir = new THREE.Vector3(0,0,-1).applyEuler(camera.rotation);
  raycaster.set(camera.position, dir);
  const intr = raycaster.intersectObjects(blocksGroup.children, false);
  return intr.length ? intr[0] : null;
}

// Break/place
window.addEventListener('mousedown', (e)=>{
  if (document.pointerLockElement !== renderer.domElement) return;
  if (e.button === 0){
    const it = getCenterRay();
    if (it){
      const u = it.object.userData;
      setBlock(u.x, u.y, u.z, BLOCK.AIR);
    }
  }
  if (e.button === 2){
    const it = getCenterRay();
    if (it){
      const u = it.object.userData; const n = it.face.normal;
      const tx = u.x + Math.round(n.x),
            ty = u.y + Math.round(n.z),
            tz = u.z + Math.round(n.y);
      if (tx>=0 && ty>=0 && tz>=0 && tx<GRID_W && ty<GRID_H && tz<GRID_D){
        if (grid[tz][ty][tx] === BLOCK.AIR){
          setBlock(tx, ty, tz, selectedBlock);
        }
      }
    }
  }
});
window.addEventListener('contextmenu', (e)=>{
  if (document.pointerLockElement === renderer.domElement) e.preventDefault();
});

// Toolbar
const toolbar = [
  BLOCK.DIRT,BLOCK.GRASS,BLOCK.SAND,BLOCK.WOOD,BLOCK.PLANK,BLOCK.STONE,
  BLOCK.WATER,BLOCK.GRAVEL,BLOCK.GLASS,BLOCK.GLOWSTONE,BLOCK.TNT,BLOCK.LAVA,BLOCK.OBSIDIAN , BLOCK.KETCAP, BLOCK.HARDAL, BLOCK.SPAGETTI, BLOCK.KURDELE, BLOCK.BURGU, BLOCK.KONIK, BLOCK.PATATES

];
let selectedIndex = 0, selectedBlock = toolbar[selectedIndex];
const toolbarEl = document.getElementById('toolbar'), blockNameEl = document.getElementById('blockName');
function iconFor(b){
  switch(b){
    case BLOCK.DIRT:      return TEX.dirt;
    case BLOCK.GRASS:     return TEX.grass_side;
    case BLOCK.SAND:      return TEX.sand;
    case BLOCK.WOOD:      return TEX.wood;
    case BLOCK.PLANK:     return TEX.plank;
    case BLOCK.STONE:     return TEX.stone;
    case BLOCK.WATER:     return TEX.water;
    case BLOCK.GRAVEL:    return TEX.gravel;
    case BLOCK.GLASS:     return TEX.glass;
    case BLOCK.GLOWSTONE: return TEX.glowstone;
    case BLOCK.TNT:       return TEX.tnt_side;
    case BLOCK.LAVA:      return TEX.lava;
    case BLOCK.OBSIDIAN:  return TEX.obsidian;
    case BLOCK.KETCAP:    return TEX.ketcap;
    case BLOCK.HARDAL:    return TEX.hardal;
    case BLOCK.SPAGETTI:  return TEX.spagetti;
    case BLOCK.KURDELE:   return TEX.kurdele;
    case BLOCK.BURGU:     return TEX.burgu;
    case BLOCK.KONIK:     return TEX.konik;
    case BLOCK.PATATES:   return TEX.patates;
    default:              return TEX.dirt;
  }
}

function buildToolbar(){
  toolbarEl.innerHTML='';
  toolbar.forEach((b,i)=>{
    const div=document.createElement('div');
    div.className='slot'+(i===selectedIndex?' selected':'');
    div.style.backgroundImage=`url(${iconFor(b)})`;
    div.title=NAMES[b]||'Block';
    div.addEventListener('click',()=>{ selectedIndex=i; selectedBlock=toolbar[selectedIndex]; updateToolbar(); });
    toolbarEl.appendChild(div);
  });
  updateToolbar();
}
function updateToolbar(){
  for(let i=0;i<toolbarEl.children.length;i++){
    toolbarEl.children[i].classList.toggle('selected',i===selectedIndex);
  }
  blockNameEl.innerText=NAMES[selectedBlock]||'Unknown';
}
buildToolbar();

// Envanter UI (E ile aç/kapat)
const invEl=document.getElementById('inventory');
const invGrid=document.getElementById('invGrid');
function toggleInventory(){
  const show = invEl.style.display!=='grid';
  invEl.style.display = show?'grid':'none';
  if(show){ buildInventory(); document.exitPointerLock?.(); }
  else { renderer.domElement.requestPointerLock?.(); }
}
function buildInventory(){
  invGrid.innerHTML='';
  toolbar.forEach(b=>{
    const s=document.createElement('div');
    s.className='invSlot';
    s.style.backgroundImage=`url(${iconFor(b)})`;
    s.title=NAMES[b];
    s.addEventListener('click',()=>{
      selectedIndex = toolbar.indexOf(b); selectedBlock=b; updateToolbar(); toggleInventory();
    });
    invGrid.appendChild(s);
  });
}


// LAV yayılması + etkileşimler
// Not: Lava'nın YAYILMASINI stepWater yönetiyor (20 blok sınırı ile).
// Bu fonksiyon artık YENİ lava hücresi üretmez; sadece istersek yan etkiler eklenebilir.
function stepLava(){
  // İleride efekt yazmak istersen:
  // - Ahşabı yak: sadece görsel/puan vs. (setBlock(BLOCK.LAVA) YAPMA!)
  // - Partikül, ses, ışık animasyonu vb.
  // Şimdilik bilerek boş.
}

// Kum/çakıl düşmesi
function stepFall(){
  for (let z = GRID_D - 2; z >= 0; z--) {
    for (let y = 0; y < GRID_H; y++) {
      for (let x = 0; x < GRID_W; x++) {
        if (grid[z][y][x] === BLOCK.SAND || grid[z][y][x] === BLOCK.GRAVEL) {
          if (grid[z - 1]?.[y]?.[x] === BLOCK.AIR) {
            setBlock(x, y, z - 1, grid[z][y][x]);
            setBlock(x, y, z, BLOCK.AIR);
          }
        }
      }
    }
  }
}

// Underwater overlay
const overlay = document.getElementById('overlay-underwater');
function updateUnderwater(){
  const ix = Math.floor((camera.position.x / BLOCK_SIZE) + GRID_W / 2);
  const iy = Math.floor((camera.position.z / BLOCK_SIZE) + GRID_H / 2);
  const iz = Math.floor((camera.position.y / BLOCK_SIZE));
  const b  = (grid[iz]?.[iy]?.[ix]) | 0;

  if (b === BLOCK.LAVA) {
    overlay.style.background = 'rgba(160,50,0,0.25)';   // lava parıltısı
  } else if (FLUIDS.has(b)) {
    overlay.style.background = (b === BLOCK.HARDAL ? 'rgba(130,90,0,0.25)' : 'rgba(0,30,70,0.25)');
  } else {
    overlay.style.background = 'rgba(0,0,0,0)';
  }
}


// Basit mob sistemi (sprite)
const mobsGroup = new THREE.Group(); scene.add(mobsGroup);
const mobGeo = new THREE.PlaneGeometry(BLOCK_SIZE,BLOCK_SIZE);
const mobs = [];
const MOB_RADIUS = 0.4;

function repelFromMobs(dt){
  const rr  = PLAYER_RADIUS + MOB_RADIUS;
  const rr2 = rr * rr;
  for (const m of mobs){
    const dx = player.x - m.x;
    const dy = player.y - m.y;
    const d2 = dx*dx + dy*dy;
    if (d2 < rr2){
      const d  = Math.sqrt(Math.max(d2, 1e-6));
      const nx = dx / d, ny = dy / d;
      const push = (rr - d) * 0.75;   // 0.6–0.9 arası deneyebilirsin
      if (push > 0){
        tryMoveTo(player.x + nx * push, player.y);
        tryMoveTo(player.x,             player.y + ny * push);
      }
    }
  }
}

function addMob(x,y,_z,type){
  // doğduğu hücrenin en üst sağlam bloğunun ÜSTÜ (yürünecek yüzey)
  const ix = x|0, iy = y|0;
let zTop = walkableTopZ(ix,iy); if (zTop<0) zTop=0;
const zSpawn = zTop + 1; // bloğun üstündeki hücre

  const tex = loader.load(type===BLOCK.PIG?TEX.pig:TEX.villager);
  tex.magFilter = THREE.NearestFilter; tex.minFilter = THREE.LinearMipMapLinearFilter;
  const mat = new THREE.MeshBasicMaterial({map:tex,transparent:true});
  const mesh = new THREE.Mesh(mobGeo,mat);

  // ÖNEMLİ: posFor(..., zSpawn) ve **EKSTRA +BLOCK_SIZE/2 YOK**
  mesh.position.copy(posFor(x,y,zSpawn));
  mesh.rotation.y = Math.PI; mobsGroup.add(mesh);

  mobs.push({x,y,z:zSpawn,mesh,type,dir:[Math.random()-.5,Math.random()-.5]});
}

addMob(GRID_W/2+5,GRID_H/2+5,2,BLOCK.PIG);
addMob(GRID_W/2-5,GRID_H/2-3,2,BLOCK.PIG);
addMob(GRID_W/2+3,GRID_H/2-4,2,BLOCK.PIG);
addMob(GRID_W/2-4,GRID_H/2+2,2,BLOCK.VILLAGER);
addMob(GRID_W/2+2,GRID_H/2-2,2,BLOCK.VILLAGER);

function updateMobs(dt){
  for(const m of mobs){
    let nx = m.mesh.position.x + m.dir[0]*dt*1.2;
    let nz = m.mesh.position.z + m.dir[1]*dt*1.2;
    const ix = Math.floor(nx/BLOCK_SIZE+GRID_W/2);
    const iy = Math.floor(nz/BLOCK_SIZE+GRID_H/2);

    let zTop = topSolidZ(ix,iy);
    if(zTop<0) zTop=0;

    // ↓↓↓ BURAYI DEĞİŞTİRİYORUZ ↓↓↓
    const curZ  = Math.floor((m.mesh.position.y - BLOCK_SIZE/2)/BLOCK_SIZE);
    const zWalk = Math.min(zTop, curZ + 1);       // en fazla 1 blok yukarı adım
    const targetY = posFor(0,0, zWalk + 1).y;     // bloğun üstündeki hücre merkezi
    // ↑↑↑ BURAYI DEĞİŞTİRİYORUZ ↑↑↑

    if(isSolidAt(ix,iy,zTop+1) || isSolidAt(ix,iy,zTop+2)){ 
      m.dir[0]*=-1; m.dir[1]*=-1; 
      continue; 
    }
    m.mesh.position.x = nx; 
    m.mesh.position.z = nz;
    m.mesh.position.y += (targetY - m.mesh.position.y) * Math.min(1, 8*dt);

    // curZ’i yukarıda zaten hesapladık; istersen bu satırı tamamen kaldır:
    // const curZ = Math.floor((m.mesh.position.y - BLOCK_SIZE/2)/BLOCK_SIZE);

    if(curZ < zTop-6){ m.mesh.material.color.set(0xff0000); } 
    else { m.mesh.material.color.set(0xffffff); }
  }
}

// TNT: ateşleme algı + zamanlayıcı + patlama
const tntTimers=new Map(); // key -> remaining(sec)
function scheduleTNT(x,y,z,delay=1.2){ tntTimers.set(keyOf(x,y,z),{x,y,z,t:delay}); }
function checkIgnitionAroundTNT(){
  for(let z=0; z<GRID_D; z++) for(let y=0;y<GRID_H; y++) for(let x=0; x<GRID_W; x++){
    if(grid[z][y][x]!==BLOCK.TNT) continue;
    const k=keyOf(x,y,z); if(tntTimers.has(k)) continue;
    // Lav komşuluğu patlatır
    const neigh=[[0,0,-1],[0,0,1],[0,1,0],[0,-1,0],[1,0,0],[-1,0,0]];
    for(const d of neigh){
      const nx=x+d[0], ny=y+d[1], nz=z+d[2];
      const b=grid[nz]?.[ny]?.[nx];
      if(b===BLOCK.LAVA){ scheduleTNT(x,y,z); break; }
    }
  }
}
function updateTNT(dt){
  const del=[];
  for(const [k,obj] of tntTimers){
    obj.t-=dt;
    // küçük yanıp sönme efekti
    const m=meshesMap.get(keyOf(obj.x,obj.y,obj.z));
    if(m){ m.visible = (Math.floor(obj.t*10)%2===0); }
    if(obj.t<=0){ explode(obj.x,obj.y,obj.z,7.5); del.push(k); }
  }
  del.forEach(k=>{
    const o=tntTimers.get(k); if(o){ const m=meshesMap.get(keyOf(o.x,o.y,o.z)); if(m) m.visible=true; }
    tntTimers.delete(k);
  });
}
function explode(cx,cy,cz,r){
  // TNT bloğunu sil
  if(grid[cz]?.[cy]?.[cx]===BLOCK.TNT) setBlock(cx,cy,cz,BLOCK.AIR);
  const r2=r*r;
  for(let z=Math.max(0,Math.floor(cz-r)); z<Math.min(GRID_D,Math.ceil(cz+r)); z++)
    for(let y=Math.max(0,Math.floor(cy-r)); y<Math.min(GRID_H,Math.ceil(cy+r)); y++)
      for(let x=Math.max(0,Math.floor(cx-r)); x<Math.min(GRID_W,Math.ceil(cx+r)); x++){
        const dx=x-cx, dy=y-cy, dz=z-cz;
        if(dx*dx+dy*dy+dz*dz<=r2){
          const b=grid[z][y][x];
          if(b!==BLOCK.OBSIDIAN) setBlock(x,y,z,BLOCK.AIR); // obsidyen dayanıklı
        }
      }
}

// Portal: 4x5 dış çerçeve (iç boşluk 2x3)
function frameAllObsidian(x0,y0,z0,dx,dy){
  // dx,dy: yön (x veya y ekseni)
  const W=4, H=5; // dış boy
  for(let i=0;i<W;i++) for(let j=0;j<H;j++){
    const ix=x0+i*dx, iy=y0+i*dy, iz=z0+j;
    const onEdge = (i===0||i===W-1||j===0||j===H-1);
    if(onEdge){
      if(grid[iz]?.[iy]?.[ix]!==BLOCK.OBSIDIAN) return false;
    } else {
      const b=grid[iz]?.[iy]?.[ix];
      if(!(b===BLOCK.AIR||b===BLOCK.PORTAL)) return false;
    }
  }
  return true;
}
function fillPortal(x0,y0,z0,dx,dy){
  // iç boşluğu (2x3) PORTAL ile doldur
  for(let i=1;i<=2;i++) for(let j=1;j<=3;j++){
    const ix=x0+i*dx, iy=y0+i*dy, iz=z0+j;
    setBlock(ix,iy,iz,BLOCK.PORTAL);
  }
}
function tryFormPortalAt(x,y,z){
  // iki yönü dene: X’e paralel (dx=1,dy=0) ve Y’ye paralel (dx=0,dy=1)
  // yerleştirilen obsidiyenin sol-alt köşede olma ihtimali için 0..3/0..4 kaydırmaları deneriz
  const cands=[
    {dx:1,dy:0},{dx:0,dy:1}
  ];
  for(const o of cands){
    for(let sx=-3;sx<=0;sx++){
      for(let sy=-4;sy<=0;sy++){
        const x0=x+sx*o.dx, y0=y+sx*o.dy, z0=z+sy;
        if(frameAllObsidian(x0,y0,z0,o.dx,o.dy)) fillPortal(x0,y0,z0,o.dx,o.dy);
      }
    }
  }
}

// Portal teması → dünya değişimi
let inNether=false, portalCooldown=0;
function checkPortalTouch(dt){
  portalCooldown=Math.max(0,portalCooldown-dt);
  if(portalCooldown>0) return;
  const ix=Math.floor((camera.position.x/BLOCK_SIZE)+GRID_W/2);
  const iy=Math.floor((camera.position.z/BLOCK_SIZE)+GRID_H/2);
  const iz=Math.floor((camera.position.y/BLOCK_SIZE));
  if(grid[iz]?.[iy]?.[ix]===BLOCK.PORTAL){
    inNether=!inNether; portalCooldown=1.5;
    if(inNether) generateNether();
    else generateOverworld();
    // oyuncuyu ortaya al
    player.x=GRID_W/2; player.y=GRID_H/2; const t=topSolidZ(Math.floor(player.x),Math.floor(player.y)); player.z=(t<0?0:t)+EYE_HEIGHT;
    rebuildMeshes();
  }
}
function generateNether(){
  // basit nether: taş, lav gölleri, obsidiyen adalar, “kırıktaş” yerine gravel
  grid = Array.from({length:GRID_D},()=>Array.from({length:GRID_H},()=>Array(GRID_W).fill(BLOCK.AIR)));
  for(let x=0;x<GRID_W;x++) for(let y=0;y<GRID_H;y++){
    const base= 3 + Math.floor( (Math.sin(x*0.09)*Math.cos(y*0.11)+1)*4 );
    for(let z=0; z<base; z++){
      let t = (z<base-2)?BLOCK.STONE: (Math.random()<0.2?BLOCK.GRAVEL:BLOCK.OBSIDIAN);
      grid[z][y][x]=t;
    }
    // lav gölleri
    if(Math.random()<0.08){
      const z0 = Math.max(1,base-2);
      for(let dz=0; dz<2; dz++) for(let dx=-2; dx<=2; dx++) for(let dy=-2; dy<=2; dy++){
        const xx=x+dx, yy=y+dy, zz=z0+dz;
        if(xx>=0&&yy>=0&&xx<GRID_W&&yy<GRID_H&&zz<GRID_D){
          if(Math.abs(dx)+Math.abs(dy)+dz<=3) grid[zz][yy][xx]=BLOCK.LAVA;
        }
      }
    }
  }
  scene.background=new THREE.Color(0x3b0b0b);
}
function generateOverworld(){
  grid = Array.from({length:GRID_D},()=>Array.from({length:GRID_H},()=>Array(GRID_W).fill(BLOCK.AIR)));
  for(let x=0;x<GRID_W;x++) for(let y=0;y<GRID_H;y++){
    const base = 2 + Math.floor( Math.abs(Math.sin(x*0.12)+Math.cos(y*0.11))*3 );
    const extraStone = Math.floor( (Math.sin(x*0.05)*Math.cos(y*0.05)+1)*2 );
    const h = base + extraStone;
    for(let z=0; z<h; z++){
      let t=BLOCK.DIRT; const v=Math.sin((x+y)*0.06)+Math.random()*0.5;
      if(z < Math.max(0,h-3)) t=BLOCK.STONE;
      else {
        if(v>0.7) t=BLOCK.STONE;
        else if(v>0.25) t=BLOCK.GRASS;
        else if(v<-0.6) t=BLOCK.SAND;
        else if(Math.random()<0.01) t=BLOCK.WATER;
        else t=BLOCK.DIRT;
      }
      grid[z][y][x]=t;
    }
  }
  // birkaç ağaç
  (function scatterTreesAgain(){
    const count = 20; let placed=0, tries=0;
    while(placed<count && tries<800){
      tries++;
      const x = Math.floor(Math.random()*GRID_W);
      const y = Math.floor(Math.random()*GRID_H);
      const ground = topSolidZ(x,y);
      if(ground<0) continue;
      const groundBlock = grid[ground][y][x];
      if(!(groundBlock===BLOCK.GRASS || groundBlock===BLOCK.DIRT || groundBlock===BLOCK.SAND)) continue;
      const h = 3 + Math.floor(Math.random()*3);
      let ok=true;
      for(let i=1;i<=h;i++){ if(isSolidAt(x,y,ground+i)) { ok=false; break; } }
      if(!ok) continue;
      for(let i=1;i<=h;i++){ grid[ground+i][y][x]=BLOCK.WOOD; }
      const topZ = ground+h;
      const r = 2;
      for(let dz=-r; dz<=r; dz++)
        for(let dy=-r; dy<=r; dy++)
          for(let dx=-r; dx<=r; dx++){
            const dist = Math.abs(dx)+Math.abs(dy)+Math.abs(dz);
            const tx=x+dx, ty=y+dy, tz=topZ+dz;
            if(dist<=r+1){
              if(dx===0 && dy===0 && dz===0){
                tryPlace(tx,ty,tz,BLOCK.GLOWSTONE);
              } else if(dist>=1){
                tryPlace(tx,ty,tz,BLOCK.GLASS);
              }
            }
          }
      placed++;
    }
  })();
  scene.background=new THREE.Color(0x87ceeb);
}

// HAREKET (yerçekimsiz + adım)
const clock=new THREE.Clock();


function tryMoveTo(nx, ny){
  // İlerleme yönleri (+1, 0, -1)
  const dirX = Math.sign(nx - player.x);
  const dirY = Math.sign(ny - player.y);

  // Hücre endeksi için YÖNSEL epsilon (pozitifte mevcut hücreyi biraz tercih et)
  const IDX_EPS = 1e-4;
  const cx = cellIdx(player.x), cy = cellIdx(player.y);
  const tx = cellIdx(nx - dirX * IDX_EPS);
  const ty = cellIdx(ny - dirY * IDX_EPS);

  // Bulunduğun yerde zemin ve "havada mıyım?"
  let curTop = walkableTopZ(cx, cy); if (curTop < 0) curTop = 0;
  const minZHere = curTop + EYE_HEIGHT;
  const airborne = (player.z > minZHere + 1e-3) || (player.vz > 0);

  if (airborne){
    // Havadayken: sadece yan çarpışmayı kontrol et
    const baseZ = Math.floor(player.z - EYE_HEIGHT);
    if (!canStandAt(nx, ny, baseZ)) return false;
    player.x = nx; player.y = ny;
    return true; // z'ye dokunma
  }

  // Yerde: hedef yüzey
  let tarTop = walkableTopZ(tx, ty); if (tarTop < 0) tarTop = 0;

  // Sadece YUKARI adımı sınırlıyoruz (aşağı adım serbest)
  if (tarTop > curTop && (tarTop - curTop) > MAX_STEP) return false;

  // AŞAĞI adımda kontrolü "mevcut yükseklikte" yap (görünmez duvarı kaldırır)
  const baseZForCheck = (tarTop < curTop) ? curTop : tarTop;

  // Yan çarpışma + su istisnası
  if (!canStandAt(nx, ny, baseZForCheck)) {
    if (isFluidColumn(tx, ty, tarTop)) {
      player.x = nx; player.y = ny; player.z = tarTop + EYE_HEIGHT;
      return true;
    }
    return false;
  }

  // Uygula
  player.x = nx; 
  player.y = ny;

  // Sadece düşerken zemine yapıştır (zıplamayı bozmaz)
  if (player.vz <= 0) {
    const minZ = tarTop + EYE_HEIGHT;
    if (player.z < minZ) player.z = minZ;
  }
  return true;
}



// X-önce ve Z-önce iki sıralamayı da deneyip en iyi ilerlemeyi uygular
function applyHorizontalMove(nx, ny){
  const x0 = player.x, y0 = player.y;

  // Sıra A: X -> Z
  let ax = x0, ay = y0;
  if (nx !== x0) { tryMoveTo(nx, ay); ax = player.x; ay = player.y; }  // X
  if (ny !== ay) { tryMoveTo(ax, ny); }                                 // Z
  const dxA = player.x - x0, dyA = player.y - y0;
  const distA = dxA*dxA + dyA*dyA;

  // Geri sar
  player.x = x0; player.y = y0;

  // Sıra B: Z -> X
  let bx = x0, by = y0;
  if (ny !== y0) { tryMoveTo(bx, ny); bx = player.x; by = player.y; }   // Z
  if (nx !== bx) { tryMoveTo(nx, by); }                                 // X
  const dxB = player.x - x0, dyB = player.y - y0;
  const distB = dxB*dxB + dyB*dyB;

  // En iyi olanı bırak; kötü olanı geri sar
  if (distA >= distB){
    player.x = x0; player.y = y0;
    if (nx !== x0) tryMoveTo(nx, y0);
    if (ny !== y0) tryMoveTo(player.x, ny);
  }
  // else: distB zaten oyuncu üzerinde uygulanmış durumda
}


// Zaman ölçer (tepeye yakın bir yere koy)
let last = performance.now();


function animate(){
  const now = performance.now();
  const dt  = Math.min((now - last) / 1000, 0.05); // saniye, 50ms tavan
  last = now;

  // --- WASD girişleri ---
  const forward = (keys['w']?1:0) - (keys['s']?1:0);
  const strafe  = (keys['d']?1:0) - (keys['a']?1:0);

  // Girişi normalize et (diyagonal hız artışı olmasın)
  let inX = strafe, inY = forward;
  const mag = Math.hypot(inX, inY);
  if (mag > 0) { inX /= mag; inY /= mag; }

  // Zıplama tuşu
  const jumpPressed = keys['space'] || keys[' '];

// Suda hız azaltma
const standingInWater = isFluidColumn(
  cellIdx(player.x),
  cellIdx(player.y),
  Math.floor(player.z - EYE_HEIGHT)
);

  const speedMul = standingInWater ? 0.6 : 1.0;

  // Taban hız (istersen 3.5 bırak) + su çarpanı
  const baseSpd = 3.5 * Math.SQRT2;
  const spd = baseSpd * speedMul;

  // Kameranın baktığı yöne göre hareket vektörü
  const fwd = new THREE.Vector3();
  camera.getWorldDirection(fwd);
  fwd.y = 0; if (fwd.lengthSq()>0) fwd.normalize();
  const up = new THREE.Vector3(0,1,0);
  const right = new THREE.Vector3().crossVectors(fwd, up).normalize();

  const move = new THREE.Vector3()
    .addScaledVector(fwd,   inY * spd * dt)
    .addScaledVector(right, inX * spd * dt);

  // World→grid eşlemesi ve yatay hareket
  const nx = player.x + move.x;
  const ny = player.y + move.z;

// Çarpışma/step kontrolü (iki sırayı da dene → en iyi ilerlemeyi uygula)
applyHorizontalMove(nx, ny);


  // Duvarlardan dışarı it (yan sızmaları düzelt)
  resolveWallCollisions();

  // --- DİKEY FİZİK (zıplama / yerçekimi) ---
  const ix = cellIdx(player.x), iy = cellIdx(player.y);
  let groundTop = walkableTopZ(ix, iy); if (groundTop < 0) groundTop = 0;
  const minZ = groundTop + EYE_HEIGHT;

  const inWater = standingInWater; // aynı bilgiyi kullan
  const onGround = (player.z <= minZ + 1e-3) && (player.vz <= 0);

  // Zıplama: zeminde veya suda
  if (jumpPressed && (onGround || inWater)) {
    player.vz = JUMP_V; // örn: 7.0 → ~1 bloktan biraz fazla
  }

  // Yerçekimi (suda daha zayıf)
  const G = inWater ? GRAVITY * 0.5 : GRAVITY; // örn: GRAVITY=-22
  player.vz += G * dt;

  // Dikey konum adayı
  let newZ = player.z + player.vz * dt;

  // Tavan çarpışması (baş hizası)
  const newBaseZ = Math.floor(newZ - EYE_HEIGHT);
  const headHits = isSolidAt(ix, iy, newBaseZ + 2);
  if (headHits && player.vz > 0) {
    newZ = player.z;     // tavan vuruldu: yukarı hareketi iptal
    player.vz = 0;
  }

  // Zemine iniş (zeminin altına geçme)
  if (newZ < minZ) {
    newZ = minZ;
    player.vz = 0;
    player.grounded = true;
  } else {
    player.grounded = false;
  }

  player.z = newZ;
  // --- DİKEY FİZİK SONU ---

  // Kamera → oyuncu konumu
  camera.position.copy( posFor(player.x, player.y, player.z) );

  // NPC güncellemeleri ve render
  updateMobs(dt);
  repelFromMobs(dt);
  // --- WATER FLOW zamanlayıcı ---
  waterTimer += dt * 1000;
  if (waterTimer >= WATER_TICK_MS){
    stepWater();
    waterTimer = 0;
}
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();   // ← BUNU EKLE

</script>
</body>
</html>
